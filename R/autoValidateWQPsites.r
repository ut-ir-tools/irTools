#' Auto-validate USEPA WQP stations
#'
#' Performs auto-validation on previously queried WQP stations combined with the existing master site list.
#' Auto-validates any new sites (i.e. those not currently in the master site list) and appends them into existing master site list flagged for acceptance, rejection, or review.
#' Checks for any new site types in new data. A warning message and a list of new site types is printed if new site types are encountered.
#' Also re-auto-validates any sites in the master site list that have previously only undergone auto-validation (to account for any changes in auto validation process) and checks existing master site list for changes in AUs, selected site types, or property boundaries.
#' 
#' @param sites_object Sites object queried from WQP to be reviewed.
#' @param master_site_file Full path and filename of master site list as generated by autoValidateWQPsites function and manual site review application (.csv).
#' @param waterbody_type_file Full path and filename of list of waterbody types and their associated IR_FLAGs (.csv)
#' @param polygon_path Full path to folder containing, AU, land ownership, and Utah state boundary 1000 m buffer polygon shapefiles.
#' @param outfile_path Path for file outputs.
#' @param ownership_assess Vector of property ownership labels to be considered in assessment process. Defaults to c("Federal","Private","State") and exclude "Tribal".
#' @return Exports a new, undated master site list to the outfile_path. If one already exists in outfile_path, it is moved to the 'edit_logs' folder and renamed with the system date.

#' @import sp
#' @import sf

#' @export
autoValidateWQPsites=function(sites_object,master_site_file,waterbody_type_file,polygon_path,outfile_path,correct_longitude=FALSE){

#########
###TESTING SETUP
# library(sp)
# library(sf)
# sites_object=sites
# master_site_file="P:\\WQ\\Integrated Report\\Automation_Development\\R_package\\lookup_tables\\wqp_master_site_file.csv"
# waterbody_type_file = "P:\\WQ\\Integrated Report\\Automation_Development\\R_package\\lookup_tables\\waterbody_type_domain_table.csv"
# polygon_path="P:\\WQ\\Integrated Report\\Automation_Development\\R_package\\demo\\02site_validation\\polygons"
# outfile_path="P:\\WQ\\Integrated Report\\Automation_Development\\R_package\\lookup_tables\\"
# correct_longitude=FALSE
########


setwd(outfile_path)
print("Reading in sites_file and master_sites_file and checking for new waterbody types...")
# Read in WQP station and results data
stn = sites_object
stn[stn==""]=NA #Make sure all blanks are NA
stn=unique(stn)

# Turn any factors to character vectors for merging w/ master sites
i <- sapply(stn, is.factor)
stn[i] <- lapply(stn[i], as.character)

# Read in waterbody type domain table
waterbody_table <- read.csv(waterbody_type_file, stringsAsFactors = FALSE)
if(any(is.na(waterbody_table$MonitoringLocationTypeName)|waterbody_table$MonitoringLocationTypeName=="")){
  stop("Monitoring location type table missing IR_FLAG data. Fill out table before proceeding.")
}
# Remove past InData column
waterbody_table=waterbody_table[,!names(waterbody_table)%in%"InData"]

# Add waterbody types from sites file to domain table
stn_site_types=data.frame(unique(stn$MonitoringLocationTypeName))
colnames(stn_site_types)="MonitoringLocationTypeName"
stn_site_types$InData="Y"
waterbody_merge <- merge(waterbody_table,stn_site_types, all=TRUE)

write.csv(waterbody_merge,waterbody_type_file,row.names = FALSE)

# Prompt user to fill out domain table before moving on to autovalidation.
if(dim(waterbody_merge)[1]>dim(waterbody_table)[1]){
  new <- dim(waterbody_merge)[1]-dim(waterbody_table)[1]
  stop(paste(new,"new monitoring location types detected and added to domain table. Update IR_FLAG column in domain table before proceeding with autovalidation tool."))}else{print("No new monitoring location types detected.")}

site_type_keep <- subset(waterbody_merge$MonitoringLocationTypeName, waterbody_merge$IR_FLAG=="ACCEPT")

#Read in master site file
master_site=read.csv(master_site_file, stringsAsFactors=FALSE)

# Ensure no duplicates in master site file which could cause erroneous duplication during merges.
master_site=unique(master_site)
orig_master <- dim(master_site) # original count of the number of records in master_site
print(paste(orig_master[1],"total master site records in file."))

# Change IR_Comment to IR_Reason in master site object.

ms_dim=dim(master_site)[1]

names(master_site)[names(master_site)=="IR_COMMENT"]="IR_REASON"
if(dim(master_site)[1]>0){master_site[master_site==""]=NA} #Make sure all blanks are NA

if(length(master_site$ValidationType[is.na(master_site$ValidationType)==TRUE])>0){
  stop("NA's detected in ValidationType column of master_site_file. Correct NA's before re-running autovalidateWQPsites.")
}
suppressWarnings({class(stn$HorizontalAccuracyMeasure.MeasureValue)="numeric"}) #Non-numeric values introduced to this column were causing appearance of duplicates in master_site_file
suppressWarnings({class(master_site$HorizontalAccuracyMeasure.MeasureValue)="numeric"})

#Identify any new sites (all review columns == NA) and move to new data frame (stn_new)
stn2=stn[,!names(stn)%in%c("LatitudeMeasure","LongitudeMeasure","HorizontalCoordinateReferenceSystemDatumName")]
stn2[stn2==""]=NA #Make sure all blanks are NA

stn2=merge(stn2,master_site,all.x=TRUE)
stn_new=stn2[is.na(stn2$UID),]
dim(stn_new)
print(paste(dim(stn_new)[1],"sites found in sites_file not present in master_site_file."))
if(dim(stn_new)[1]==0){
  readline(prompt="Press [enter] to continue with master_site autovalidation or [esc] to end function.")
}else{readline(prompt="Press [enter] to continue.")}
rm(stn2)


#Assign UID to new sites
if(dim(master_site)[1]>0&dim(stn_new)[1]>0){
	stn_new$UID=seq(1:dim(stn_new)[1])+max(master_site$UID)
}else{
	if(dim(stn_new)[1]>0){
		stn_new$UID=seq(1:dim(stn_new)[1])}
	}

#Delete lat, long, and datum columns from new sites data frame. Then merge back in from stn.
table(stn_new$HorizontalCoordinateReferenceSystemDatumName)
stn_new=stn_new[,!names(stn_new)%in%c("LatitudeMeasure","LongitudeMeasure","HorizontalCoordinateReferenceSystemDatumName")]
stn_new=merge(stn_new,stn,all.x=TRUE)
dim(stn_new)
table(as.factor(stn_new$HorizontalCoordinateReferenceSystemDatumName))

#Read in polygons
ut_poly=st_read(polygon_path,"UT_state_bnd_noTribal_wgs84")
ut_poly=ut_poly[,"STATE_NAME"]
suppressWarnings({ut_poly=st_buffer(ut_poly, 0)})
#lo_poly=st_read(polygon_path,"tribal_ownership_wgs84")
#lo_poly=lo_poly[,"OWNERSHIP"]
#lo_poly=st_buffer(lo_poly, 0)
au_poly=st_read(polygon_path,"AU_poly_wgs84")
au_poly=au_poly[,c("ASSESS_ID","AU_NAME","AU_Type")]
au_poly=st_read(polygon_path,"AU_poly_wgs84")
au_poly=au_poly[au_poly$Status=="ACTIVE",c("ASSESS_ID","AU_NAME","AU_Type")]
bu_poly=st_read(polygon_path,"Beneficial_Uses_All_2020IR_wgs84")
bu_poly=bu_poly[bu_poly$Status=="ACTIVE",c("R317Descrp","BenUseClas","Water_Type")]
names(bu_poly)[names(bu_poly)=="BenUseClas"]="BEN_CLASS"
ss_poly=st_read(polygon_path,"SiteSpecific_wgs84")
ss_poly=ss_poly[ss_poly$Status=="ACTIVE","R317Descrp"]
names(ss_poly)[names(ss_poly)=="R317Descrp"]="ss_R317Descrp"
gsl_poly=st_read(paste0(polygon_path),"GSL_poly_wgs84")


##################################
####Master site reviews
if(dim(master_site)[1]>0){
	#Kick master sites that were previously accepted or merged, but are now at a non-assessed site type etc. to AUTO validation (convert review type to AUTO)
	#(where they will be rejected, doing this here keeps them out of later master site spatial count based checks)
	
	##Send to AUTO review by datum
	#table(master_site$ValidationType)
	#master_site$ValidationType[master_site$HorizontalCoordinateReferenceSystemDatumName!="WGS84"]="AUTO"
	#table(master_site$ValidationType)
	
  print("Performing master site reviews...")
  
	#Site type
	table(master_site$ValidationType)
	master_site$ValidationType[!master_site$MonitoringLocationTypeName %in% site_type_keep]="AUTO"
	table(master_site$ValidationType)
	
	#Remove OWNERSHIP, ASSESS_ID, & AU_NAME cols from master_site before re-assigning (this updates master list in case polygons change)
	master_site=master_site[,!names(master_site)%in%c("OWNERSHIP","ASSESS_ID","AU_NAME","AU_Type","BEN_CLASS","R317Descrp","ss_R317Descrp","Water_Type")]	
	class(master_site$IR_FLAG)
	dim(master_site)
	
	#Generate spatial sites object
	sites=master_site
	coordinates(sites)=c("LongitudeMeasure","LatitudeMeasure")
	proj4string(sites)=CRS("+init=epsg:4326")
	sites=st_as_sf(sites)
	
	#Intersect sites with polygons using intpoly function
	intpoly <- function(polygon,sites_object){
	  isect=suppressMessages({suppressWarnings({st_intersection(sites, polygon)})})
	  st_geometry(isect)=NULL
	  check=dim(sites_object)[1]
	  sites_object=merge(sites_object,isect,all.x=TRUE)
	  if(dim(sites_object)[1]!=check){
	    stop("Spatial join and merge causing duplicated values.")
	  }
	  return(sites_object)
	 }
	#Intersect sites w/ Utah poly, AU poly, BU poly, and SS poly 
	master_site <- intpoly(ut_poly,master_site)
	master_site <- intpoly(au_poly,master_site)
	master_site <- intpoly(bu_poly,master_site)
	master_site <- intpoly(ss_poly,master_site)
	
	rm(sites)

	#Send to AUTO review by is.na(STATE_NAME)
	table(master_site$ValidationType)
	master_site$ValidationType[is.na(master_site$STATE_NAME)]="AUTO"
	table(master_site$ValidationType)
	master_site=master_site[,!names(master_site) %in% "STATE_NAME"]
	
	#Send to AUTO review by is.na(AU)
	table(master_site$ValidationType)
	master_site$ValidationType[is.na(master_site$ASSESS_ID)]="AUTO"
	table(master_site$ValidationType)

	#Send to AUTO where 	MonitoringLocationTypeName is a canal type & AU_Type!="Canal"
	master_site$ValidationType[
		(master_site$MonitoringLocationTypeName=="Stream: Canal" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="Stream: Ditch" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="Canal Transport" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="Canal Drainage" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="Canal Irrigation" & master_site$AU_Type != "Canal")
		]="AUTO"
	table(master_site$ValidationType)

	#Send to AUTO where MonitoringLocationTypeName is a stream or spring type & AU_Type!="River/Stream" or "Canal"
	master_site$ValidationType[
		(master_site$MonitoringLocationTypeName=="Stream" & master_site$AU_Type != "River/Stream")&
		(master_site$MonitoringLocationTypeName=="Stream" & master_site$AU_Type != "Canal") |
		(master_site$MonitoringLocationTypeName=="River/Stream" & master_site$AU_Type != "River/Stream")&
		(master_site$MonitoringLocationTypeName=="River/Stream" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="River/Stream Intermittent" & master_site$AU_Type != "River/Stream")&
		(master_site$MonitoringLocationTypeName=="River/Stream Intermittent" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="River/Stream Perennial" & master_site$AU_Type != "River/Stream")&
		(master_site$MonitoringLocationTypeName=="River/Stream Perennial" & master_site$AU_Type != "Canal")|
		(master_site$MonitoringLocationTypeName=="Spring" & master_site$AU_Type != "River/Stream")&
		(master_site$MonitoringLocationTypeName=="Spring" & master_site$AU_Type != "Canal")
		]="AUTO"
	table(master_site$ValidationType)

	#Send to AUTO where MonitoringLocationTypeName is a lake type & AU_Type!="Reservoir/Lake"
	master_site$ValidationType[
		(master_site$MonitoringLocationTypeName=="Lake, Reservoir, Impoundment" & master_site$AU_Type != "Reservoir/Lake")|
		(master_site$MonitoringLocationTypeName=="Lake" & master_site$AU_Type != "Reservoir/Lake")|
		(master_site$MonitoringLocationTypeName=="Reservoir" & master_site$AU_Type != "Reservoir/Lake")
		]="AUTO"
	table(master_site$ValidationType)

	##Send to AUTO review by !OWNERSHIP %in% ownership_assess
	#table(master_site$ValidationType)
	#master_site$ValidationType[!master_site$OWNERSHIP %in% ownership_assess]="AUTO"
	#table(master_site$ValidationType)
	mast_autval <- length(master_site$ValidationType[master_site$ValidationType=="AUTO"])
	mast_man <- length(master_site$ValidationType[master_site$ValidationType=="MANUAL"])
	new_autval <- length(stn_new[,1])
	if(mast_autval+mast_man!=orig_master[1]){
	  stop("Dimensions of master_site have changed following master site reviews. Function/file check needed.")
	}
	#Send master sites that have only undergone AUTO validation or were flagged for AUTO review above to stn_new (i.e. re-auto review those sites to account for any changes in automated review process)
	stn_new=rbind(stn_new,master_site[master_site$ValidationType=="AUTO",])
	dim(stn_new)
	table(stn_new$HorizontalCoordinateReferenceSystemDatumName)
	
	#Remove stn_new sites from master_site
	dim(master_site)
	master_site=master_site[!master_site$UID%in%stn_new$UID,]
	dim(master_site)
	dim(stn_new)
	print(paste(mast_autval,"master site(s) and", new_autval,"new site(s) sent to AUTO review.",mast_man,"master site(s) have undergone previous manual review and have not been flagged for further review."))
	readline(prompt="Press [enter] to continue.")
}else{
  mast_autval <- length(master_site$ValidationType[master_site$ValidationType=="AUTO"])
  mast_man <- length(master_site$ValidationType[master_site$ValidationType=="MANUAL"])
  new_autval <- length(stn_new[,1])
  intpoly <- function(polygon,sites_object){
  isect=suppressMessages({suppressWarnings({st_intersection(sites, polygon)})})
  st_geometry(isect)=NULL
  check=dim(sites_object)[1]
  sites_object=merge(sites_object,isect,all.x=TRUE)
  if(dim(sites_object)[1]!=check){
    stop("Spatial join and merge causing duplicated values.")
  }
  return(sites_object)
}}


######################################
######################################

print("Performing attribute based site checks...")

#Stop execution if there are no new sites
if(dim(stn_new)[1]==0){stop("No new sites identified. This is suspicious. Double check inputs. Coding modification may be required.",call.=FALSE)}


#Correct positive longitudes (if correct_longitude==TRUE) (JV note, moved to apply to all stations that will undergo auto review - stn_new)
if(correct_longitude==TRUE){
  stn_new$LongitudeMeasure[stn_new$LongitudeMeasure>0]<- -stn_new$LongitudeMeasure[stn_new$LongitudeMeasure>0]
}

# Create IR specific columns, all values filled w/ "REVIEW"
stn_new[,c("IR_MLID","IR_MLNAME","IR_FLAG","IR_REASON")] = "REVIEW"
stn_new[,c("IR_Lat","IR_Long")] = NA


##Auto review new sites & master sites re-flagged to AUTO...
rej_reasons_att=data.frame(matrix(nrow=0,ncol=2))

# If [MonitoringLocationDescriptionText] contains "Duplicate","Replicate","Dummy","replaced","Blank","QA", or "QC", reject as QAQC
reason_n = ifelse(grepl("Duplicate",stn_new$MonitoringLocationDescriptionText) | grepl("Replicate",stn_new$MonitoringLocationDescriptionText) | grepl("Dummy",stn_new$MonitoringLocationDescriptionText) | 
                        grepl("replaced",stn_new$MonitoringLocationDescriptionText) | grepl("Blank",stn_new$MonitoringLocationDescriptionText) | grepl("QA",stn_new$MonitoringLocationDescriptionText) | 
                        grepl("QC",stn_new$MonitoringLocationDescriptionText),"Attributes indicate dup, rep, blank, dummy, or QAQC site",NA)

if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

# If [OrganizationIdentifier] is test or demo, reject site.
reason_n=ifelse(stn_new$OrganizationIdentifier%in%c("OST_SHPD_TEST","DEMOTEST"),"Organization identifier indicates test/demo",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites where horizontal datum =="UNKWN")
reason_n=ifelse(stn_new$HorizontalCoordinateReferenceSystemDatumName=="UNKWN","Horizontal datum unknown",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with ConstructionDateText populated
reason_n=ifelse(!is.na(stn_new$ConstructionDateText),"Construction date text populated",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with WellDepthMeasure.MeasureValue populated
reason_n=ifelse(!is.na(stn_new$WellDepthMeasure.MeasureValue),"Well depth measure populated",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with WellDepthMeasure.MeasureUnitCode populated
reason_n=ifelse(!is.na(stn_new$WellDepthMeasure.MeasureUnitCode),"Well depth measure unit code populated",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with WellHoleDepthMeasure.MeasureValue populated
reason_n=ifelse(!is.na(stn_new$WellHoleDepthMeasure.MeasureValue),"Well hole depth measure populated",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with WellHoleDepthMeasure.MeasureUnitCode populated
reason_n=ifelse(!is.na(stn_new$WellHoleDepthMeasure.MeasureUnitCode),"Well hole depth measure unit code populated",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with AquiferName populated
reason_n=ifelse(!is.na(stn_new$AquiferName),"Aquifer name populated: associated with unassessed wells",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with FormationTypeText populated
reason_n=ifelse(!is.na(stn_new$FormationTypeText),"Formation type populated: associated with unassessed wells",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites with AquiferTypeName populated
reason_n=ifelse(!is.na(stn_new$AquiferTypeName),"Aquifer type name populated: associated with unassessed wells",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject sites where MonitoringLocationTypeName !%in% site_type_keep argument
reason_n=ifelse(!stn_new$MonitoringLocationTypeName%in%site_type_keep,"Non-assessed site type",NA)
if(length(reason_n)>0){rej_reasons_att=rbind(rej_reasons_att,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

names(rej_reasons_att)=c("MonitoringLocationIdentifier","Reason")
rej_reasons_att$ReasonType="Attribute based"
rej_reasons_att$FLAG="REJECT"
head(rej_reasons_att)

print("Attribute based site rejection reason count:")
print(table(rej_reasons_att$Reason))
readline(prompt="Press [enter] to continue.")

#Set stn_new IR_FLAG and reason for attribute based site rejections
stn_new$IR_FLAG[stn_new$MonitoringLocationIdentifier %in% rej_reasons_att$MonitoringLocationIdentifier]="REJECT"
table(stn_new$IR_FLAG)



####################
###Spatial checks###
####################


#Check for datums that != NAD27, NAD83, or WGS84 before screening on lat/long
#Convert NAD27 and NAD83 lat/long to WGS84, replace old rows w/new coordinates
print("Performing spatial site checks...")

if(all(stn_new$HorizontalCoordinateReferenceSystemDatumName[stn_new$IR_FLAG!="REJECT"]%in%c("NAD27","NAD83","WGS84"))=="TRUE"){
	temp=stn_new[stn_new$HorizontalCoordinateReferenceSystemDatumName=="NAD27",]
	if(dim(temp)[1]>0){
		coordinates(temp)=c("LongitudeMeasure","LatitudeMeasure")
		proj4string(temp)=CRS("+init=epsg:4267")
		CRS.new=CRS("+init=epsg:4326")
		coords_NAD27toWGS84=spTransform(temp, CRS.new)
		coords_NAD27toWGS84$HorizontalCoordinateReferenceSystemDatumName="WGS84"
		coords_NAD27toWGS84=as.data.frame(coords_NAD27toWGS84)
	}else{
		coords_NAD27toWGS84=data.frame(matrix(ncol = dim(stn_new)[2], nrow = 0))
		names(coords_NAD27toWGS84)=names(stn_new)
		}
	
	temp=stn_new[stn_new$HorizontalCoordinateReferenceSystemDatumName=="NAD83",]
	if(dim(temp)[1]>0){
		coordinates(temp)=c("LongitudeMeasure","LatitudeMeasure")
		proj4string(temp)=CRS("+init=epsg:4269")
		CRS.new=CRS("+init=epsg:4326")
		coords_NAD83toWGS84=spTransform(temp, CRS.new)
		coords_NAD83toWGS84$HorizontalCoordinateReferenceSystemDatumName="WGS84"
		coords_NAD83toWGS84=as.data.frame(coords_NAD83toWGS84)
	}else{
		coords_NAD83toWGS84=data.frame(matrix(ncol = dim(stn_new)[2], nrow = 0))
		names(coords_NAD83toWGS84)=names(stn_new)
		}
	stn_new=stn_new[stn_new$HorizontalCoordinateReferenceSystemDatumName!="NAD27"&stn_new$HorizontalCoordinateReferenceSystemDatumName!="NAD83",]
	stn_new=rbind(stn_new,coords_NAD27toWGS84,coords_NAD83toWGS84)
	stn_new=as.data.frame(stn_new)
	}else{stop("Datum other than NAD27, NAD83, or WGS84 present. Need to add conversion to R code.")}
dim(stn_new)
table(stn_new$HorizontalCoordinateReferenceSystemDatumName)


########
#Remove OWNERSHIP, ASSESS_ID, AU_NAME, & AU_Type cols from stn_new before re-assigning for all sites (this updates master list in case polygons change)
stn_new=stn_new[,!names(stn_new)%in%c("OWNERSHIP","ASSESS_ID","AU_NAME","AU_Type","BEN_CLASS","R317Descrp","ss_R317Descrp","Water_Type")]
class(stn_new$IR_FLAG)
dim(stn_new)

#Create spatial sites object
sites=stn_new
coordinates(sites)=c("LongitudeMeasure","LatitudeMeasure")
proj4string(sites)=CRS("+init=epsg:4326")
sites=st_as_sf(sites)

#Intersect sites w/ Utah poly, AU poly, BU poly, SS poly, and GSL poly 
stn_new <- intpoly(ut_poly,stn_new)
stn_new <- intpoly(au_poly,stn_new)
stn_new <- intpoly(bu_poly,stn_new)
stn_new <- intpoly(ss_poly,stn_new)
stn_new <- intpoly(gsl_poly,stn_new)

rm(sites)

###Spatial rejections
rej_reasons_spat=data.frame(matrix(nrow=0,ncol=2))

#Reject by is.na(AU)
reason_n=ifelse(is.na(stn_new$ASSESS_ID),"Undefined AU",NA)
if(length(reason_n)>0){rej_reasons_spat=rbind(rej_reasons_spat,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject by is.na(STATE_NAME)
reason_n=ifelse(is.na(stn_new$STATE_NAME),"Non-jurisdictional: out of state or within tribal boundaries",NA)
if(length(reason_n)>0){rej_reasons_spat=rbind(rej_reasons_spat,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Reject by GSL poly
reason_n=ifelse(!is.na(stn_new$Id),"GSL assessed through separate program",NA)
if(length(reason_n)>0){rej_reasons_spat=rbind(rej_reasons_spat,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#Remove unneeded spatial join columns
stn_new=stn_new[,!names(stn_new)%in%c("STATE_NAME","Id")]

#Reject where 	MonitoringLocationTypeName is a canal type & AU_Type!="Canal"
reason_n=ifelse(
				(stn_new$MonitoringLocationTypeName=="Stream: Canal" & stn_new$AU_Type != "Canal")|
				(stn_new$MonitoringLocationTypeName=="Stream: Ditch" & stn_new$AU_Type != "Canal")|
				(stn_new$MonitoringLocationTypeName=="Canal Transport" & stn_new$AU_Type != "Canal")|
				(stn_new$MonitoringLocationTypeName=="Canal Drainage" & stn_new$AU_Type != "Canal")|
				(stn_new$MonitoringLocationTypeName=="Canal Irrigation" & stn_new$AU_Type != "Canal")
		,"Non-assessed canal or ditch",NA)
if(length(reason_n)>0){rej_reasons_spat=rbind(rej_reasons_spat,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}


#Reject where 	MonitoringLocationTypeName is a stream or spring type & AU_Type!="River/Stream"
reason_n=ifelse(
		(stn_new$MonitoringLocationTypeName=="Stream" & stn_new$AU_Type != "River/Stream")|
		(stn_new$MonitoringLocationTypeName=="River/Stream" & stn_new$AU_Type != "River/Stream")|
		(stn_new$MonitoringLocationTypeName=="River/Stream Intermittent" & stn_new$AU_Type != "River/Stream")|
		(stn_new$MonitoringLocationTypeName=="River/Stream Perennial" & stn_new$AU_Type != "River/Stream")|
		(stn_new$MonitoringLocationTypeName=="Spring" & stn_new$AU_Type != "River/Stream")
	,"Stream or spring site type in non-River/Stream AU",NA)

rej_reasons_spat=rbind(rej_reasons_spat,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))

names(rej_reasons_spat)=c("MonitoringLocationIdentifier","Reason")
rej_reasons_spat$ReasonType="Spatial"
rej_reasons_spat$FLAG="REJECT"
head(rej_reasons_spat)

print("Spatial site rejection reason count:")
print(table(rej_reasons_spat$Reason))
readline(prompt="Press [enter] to continue.")

#Set stn_new IR_FLAG and reason for spatial site rejections
stn_new$IR_FLAG[stn_new$MonitoringLocationIdentifier %in% rej_reasons_spat$MonitoringLocationIdentifier]="REJECT"
table(stn_new$IR_FLAG)


##########
##Calculate full distance matrix, lat/long, mlid, and site 100m counts.
##For new sites and master flagged for re-AUTO (stn_new), apply lat/long, 100 m site count logic to determine review status
##For previously manually reviewed master sites, check if MLID_Count, Lat_Count, Long_Count, or sites100m_count have increased, flag these for review

print("Performing 100m/duplicate MLID/duplicate lat-long checks...")

#rbind new auto-validated sites back to master file and calculate distances on all non-rejected sites in master file (this way if polygons change, it is automatically accounted for in master file)
spatial_check_data=rbind(master_site,stn_new)
dim(spatial_check_data)

#Splitting off rejected sites prior to other spatial analyses (including all previously accepted/merged sites allows calc of distances including previously reviewed sites.)

accept_review=spatial_check_data[spatial_check_data$IR_FLAG!="REJECT",]
rejected=spatial_check_data[spatial_check_data$IR_FLAG=="REJECT",]
class(accept_review$IR_FLAG)

table(accept_review$IR_FLAG)
sum(table(accept_review$IR_FLAG))

#Count MLIDs, add as column to accept_review, MLID_Count>1 means duplicated MLID
MLID_Count=as.vector(table(accept_review$MonitoringLocationIdentifier)[accept_review$MonitoringLocationIdentifier])
accept_review$MLID_Count=MLID_Count

#Count Latitudes, add as column to accept_review, Lat_Count>1 means duplicated lat
Lat_Count=as.vector(table(accept_review$LatitudeMeasure))[as.factor(accept_review$LatitudeMeasure)]
accept_review$Lat_Count=Lat_Count

#Count Longitudes, add as column to accept_review, Long_Count>1 means duplicated long
Long_Count=as.vector(table(accept_review$LongitudeMeasure))[as.factor(accept_review$LongitudeMeasure)]
accept_review$Long_Count=Long_Count

#Identify non-rejected sites w/in 100 m (0.1 km)
distmat=spDists(cbind(accept_review$LongitudeMeasure,accept_review$LatitudeMeasure),longlat=TRUE)
row.names(distmat)=accept_review$MonitoringLocationIdentifier
colnames(distmat)=accept_review$MonitoringLocationIdentifier

sum(table(accept_review$IR_FLAG))

countSites100m=function(data){
	count=sum(data>0&data<=0.1)
	#names(data[data>0&data<=0.1])
	return(count)
	}

sites100m_count=apply(distmat,1,FUN='countSites100m')
accept_review$sites100m_count=sites100m_count

rejected$sites100m_count=NA
rejected$MLID_Count=NA
rejected$Lat_Count=NA
rejected$Long_Count=NA

#Re-appending rejected data
spatial_check_data=rbind(accept_review,rejected)
table(spatial_check_data$IR_FLAG)
sum(table(spatial_check_data$IR_FLAG))
rm(accept_review)
rm(rejected)


#Join spatial checks to stn_new (drop spatial count columns then merge)
dim(stn_new)
stn_new=stn_new[,!names(stn_new)%in%c("ASSESS_ID","AU_NAME","AU_Type","BEN_CLASS","R317Descrp","ss_R317Descrp","OWNERSHIP","ValidationType","MLID_Count","Lat_Count","Long_Count","sites100m_count")]
stn_new=merge(stn_new,spatial_check_data,all.x=T)
dim(stn_new)
stn_new$ValidationType="AUTO"


#Spatial review flags & reasons (Apply to stn_new only)
#Populate stn_new$MLID & lat/long for new sites w/ no duplicate MLIDS, lats, longs, and 0 other sites w/in 100m (IR_FLAG=="REVIEW" for all non-rejected new sites at this point)
stn_new$IR_MLID = ifelse(stn_new$IR_FLAG=="REVIEW"&stn_new$MLID_Count==1&stn_new$Lat_Count==1&stn_new$Long_Count==1&stn_new$sites100m_count==0,as.vector(stn_new$MonitoringLocationIdentifier),"REVIEW")
stn_new$IR_MLNAME = ifelse(stn_new$IR_FLAG=="REVIEW"&stn_new$MLID_Count==1&stn_new$Lat_Count==1&stn_new$Long_Count==1&stn_new$sites100m_count==0,as.vector(stn_new$MonitoringLocationName),NA)
stn_new$IR_Lat = ifelse(stn_new$IR_FLAG=="REVIEW"&stn_new$MLID_Count==1&stn_new$Lat_Count==1&stn_new$Long_Count==1&stn_new$sites100m_count==0,stn_new$LatitudeMeasure,NA)
stn_new$IR_Long = ifelse(stn_new$IR_FLAG=="REVIEW"&stn_new$MLID_Count==1&stn_new$Lat_Count==1&stn_new$Long_Count==1&stn_new$sites100m_count==0,stn_new$LongitudeMeasure,NA)

#Populate rejected MLID, lat, and long w/ REJECT
stn_new$IR_MLID = ifelse(stn_new$IR_FLAG=="REJECT","REJECT",as.vector(stn_new$IR_MLID))
stn_new$IR_MLNAME = ifelse(stn_new$IR_FLAG=="REJECT","REJECT",as.vector(stn_new$IR_MLNAME))
stn_new$IR_Lat = ifelse(stn_new$IR_FLAG=="REJECT",NA,stn_new$IR_Lat)
stn_new$IR_Long = ifelse(stn_new$IR_FLAG=="REJECT",NA,stn_new$IR_Long)


#Review reasons
review_reasons=data.frame(matrix(nrow=0,ncol=2))

#MLID, lat/long, and site 100 m counts
reason_n=ifelse(stn_new$MLID_Count>1,"Duplicated MLID",NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

reason_n=ifelse(stn_new$Lat_Count>1 | stn_new$Long_Count>1,"Duplicated lat or long",NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

reason_n=ifelse(stn_new$sites100m_count>=1,"One or more sites w/in 100 m",NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}

#MonitoringLocationTypeName is a stream or spring type & AU_Type=="Canal"
reason_n=ifelse(
			(stn_new$MonitoringLocationTypeName=="Stream" & stn_new$AU_Type == "Canal")|
			(stn_new$MonitoringLocationTypeName=="River/Stream" & stn_new$AU_Type == "Canal")|
			(stn_new$MonitoringLocationTypeName=="River/Stream Intermittent" & stn_new$AU_Type == "Canal")|
			(stn_new$MonitoringLocationTypeName=="River/Stream Perennial" & stn_new$AU_Type == "Canal")|
			(stn_new$MonitoringLocationTypeName=="Spring" & stn_new$AU_Type == "Canal")
		,"Stream or spring site type in canal AU type",NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)

#MonitoringLocationTypeName is a lake type & AU_Type!="Reservoir/Lake"
reason_n=ifelse(
	(stn_new$MonitoringLocationTypeName=="Lake, Reservoir, Impoundment" & stn_new$AU_Type != "Reservoir/Lake")|
	(stn_new$MonitoringLocationTypeName=="Lake" & stn_new$AU_Type != "Reservoir/Lake")|
	(stn_new$MonitoringLocationTypeName=="Reservoir" & stn_new$AU_Type != "Reservoir/Lake")
	,"MLID type is lake/reservoir, but AU_Type is not - potential new AU needed",NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(stn_new$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)


#Join spatial checks to master_site
spatial_check_data=spatial_check_data[,names(spatial_check_data) %in% c("UID","MLID_Count","Lat_Count","Long_Count","sites100m_count")]
names(spatial_check_data)=c("UID","MLID_Count2","Lat_Count2","Long_Count2","sites100m_count2")
master_site=merge(master_site,spatial_check_data,all.x=T)

#Check if MLID_Count, Lat_Count, Long_Count, or sites100m_count have increased, flag these for review
reason_n=ifelse(master_site$MLID_Count2>master_site$MLID_Count,"Master site MLID count has increased", NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(master_site$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)

reason_n=ifelse(master_site$Lat_Count2>master_site$Lat_Count,"Master site lat count has increased", NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(master_site$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)

reason_n=ifelse(master_site$Long_Count2>master_site$Long_Count,"Master site long count has increased", NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(master_site$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)

reason_n=ifelse(master_site$sites100m_count2>master_site$sites100m_count,"Master site sites w/in 100 m count has increased", NA)
if(length(reason_n)>0){review_reasons=rbind(review_reasons,na.omit(cbind(master_site$MonitoringLocationIdentifier,reason_n)))}
table(review_reasons$reason_n)


#Rename review reason columns
names(review_reasons)=c("MonitoringLocationIdentifier","Reason")
review_reasons$ReasonType="Spatial"
review_reasons$FLAG="REVIEW"


print("Spatial site review reason count:")
print(table(review_reasons$Reason))


#rbind reasons together
reject_reasons=rbind(rej_reasons_att,rej_reasons_spat)
reasons_all=rbind(reject_reasons, review_reasons)


#Update master_site MLID_Count, Lat_Count, Long_Count, or sites100m
master_site$MLID_Count=master_site$MLID_Count2
master_site$Lat_Count=master_site$Lat_Count2
master_site$Long_Count=master_site$Long_Count2
master_site$sites100m_count=master_site$sites100m_count2

#Drop master_site MLID_Count2, Lat_Count2, Long_Count2, and sites100m2
master_site=master_site[,!names(master_site) %in% c("MLID_Count2","Lat_Count2","Long_Count2","sites100m_count2")]


#Populate ACCEPT for new sites w/ no duplicate MLIDS, lats, longs, and 0 other sites w/in 100m (IR_FLAG=="REVIEW" for all non-rejected new sites at this point)
stn_new=within(stn_new,{
	IR_FLAG[!MonitoringLocationIdentifier %in% reasons_all$MonitoringLocationIdentifier &IR_FLAG!="REJECT" & MLID_Count==1 & Lat_Count==1 & Long_Count==1 & sites100m_count==0]<-"ACCEPT"
})

print(paste(" Site validation complete and autovalidation resulted in", table(stn_new$IR_FLAG)[1],"accepted sites,",table(stn_new$IR_FLAG)[2],"rejected sites, and",table(stn_new$IR_FLAG)[3],"sites in need of review."))

#rbind master_site & stn_new to make full list of all sites (master_new)
master_site$IR_REASON=as.factor(master_site$IR_REASON)
stn_new$IR_REASON=as.factor(stn_new$IR_REASON)
master_new=rbind(master_site, stn_new)

if(any(master_new$MonitoringLocationIdentifier[master_new$IR_FLAG=="ACCEPT" & master_new$ValidationType=="AUTO"] %in% reasons_all$MonitoringLocationIdentifier)){
  stop("Accepted site represented in reject/review site log. Check function code rules for unintended exceptions.")
}


###Set IR_FLAG for REJECT & REVIEW 
master_new=within(master_new,{
	IR_FLAG[MonitoringLocationIdentifier %in% review_reasons$MonitoringLocationIdentifier]="REVIEW"
	IR_FLAG[MonitoringLocationIdentifier %in% reject_reasons$MonitoringLocationIdentifier]="REJECT"
})


#Set IR_REASON
master_new$IR_REASON=as.character(master_new$IR_REASON)
master_new=within(master_new,{
	IR_REASON[IR_FLAG=="REJECT" & ValidationType=="AUTO"]="Automatically flagged for rejection"
	IR_REASON[IR_FLAG=="REVIEW" & ValidationType=="AUTO"]="Automatically flagged for review"
	IR_REASON[IR_FLAG=="ACCEPT" & ValidationType=="AUTO"]="Automatically accepted"
})

#Set ValidationType to AUTO for any MLID in review reasons (this is for previously manually reviewed sites that now have a review reason e.g. MLID count has increased)
master_new=within(master_new,{
	ValidationType[MonitoringLocationIdentifier %in% reasons_all$MonitoringLocationIdentifier]="AUTO"
})



####Sort by UID and re-order columns before writing
master_new=master_new[order(master_new$UID),]
master_new=master_new[,c("UID","OrganizationIdentifier","OrganizationFormalName","ProviderName","MonitoringLocationIdentifier","MonitoringLocationName","MonitoringLocationTypeName","MonitoringLocationDescriptionText",
		   "IR_FLAG","IR_REASON","IR_MLID","IR_MLNAME","ASSESS_ID","AU_NAME", "AU_Type","Water_Type", "R317Descrp", "ss_R317Descrp", "BEN_CLASS", "MLID_Count","Lat_Count","Long_Count","sites100m_count","LatitudeMeasure","LongitudeMeasure","IR_Lat","IR_Long","HUCEightDigitCode",
		   "DrainageAreaMeasure.MeasureValue","DrainageAreaMeasure.MeasureUnitCode","ContributingDrainageAreaMeasure.MeasureValue","ContributingDrainageAreaMeasure.MeasureUnitCode",
		   "SourceMapScaleNumeric","HorizontalAccuracyMeasure.MeasureValue","HorizontalAccuracyMeasure.MeasureUnitCode","HorizontalCollectionMethodName","HorizontalCoordinateReferenceSystemDatumName",
		   "VerticalMeasure.MeasureValue","VerticalMeasure.MeasureUnitCode","VerticalAccuracyMeasure.MeasureValue","VerticalAccuracyMeasure.MeasureUnitCode","VerticalCollectionMethodName",
		   "VerticalCoordinateReferenceSystemDatumName","CountryCode","StateCode","CountyCode","AquiferName","FormationTypeText","AquiferTypeName","ConstructionDateText","WellDepthMeasure.MeasureValue",
		   "WellDepthMeasure.MeasureUnitCode","WellHoleDepthMeasure.MeasureValue","WellHoleDepthMeasure.MeasureUnitCode","ValidationType")]

levels(master_new$AU_Type)=c(levels(master_new$AU_Type),"Undefined")
master_new$AU_Type[is.na(master_new$AU_Type)]="Undefined"
names(master_new)[names(master_new)=="IR_REASON"]="IR_COMMENT"

newsitesadded <- dim(master_new)[1]-orig_master[1]
if(newsitesadded!=new_autval){
  print("WARNING: discrepancy in number of sites added to master site list and number of new sites detected. Code/data review needed.")
}
if(dim(master_new)[2]!=orig_master[2]){
  print("WARNING: discrepancy in number of columns in old and updated master site list. Code/data review needed.")
}
print(paste("Updated master site list has",dim(master_new)[1],"sites, with", newsitesadded,"new sites added to original",orig_master[1],"sites in master list."))

# Export the file with all FLAG, REJECT, and FINE data included as the marked-up master file			
if(file.exists("wqp_master_site_file.csv")){
	file.rename("wqp_master_site_file.csv", paste0("wqp_master_site_file_",Sys.Date(),".csv"))
	file.copy(paste0("wqp_master_site_file_",Sys.Date(),".csv"),to="edit_logs")
	file.remove(paste0("wqp_master_site_file_",Sys.Date(),".csv"))
}

write.csv(master_new, file="wqp_master_site_file.csv",row.names=F)
write.csv(reasons_all,file="rev_rej_reasons.csv",row.names=F)


print("Master site file updated and review/rejection reasons file created.")
print(paste0(outfile_path,"\\wqp_master_site_file.csv"))
print(paste0(outfile_path,"\\rev_rej_reasons.csv"))

}















#Reject sites with same MLIDs as other REJECT sites (JV no longer needed, using same approach for all rejections now)
## This can happen when a site is rejected due to populated fields associated with demos, duplicates, well construction, etc., but a second record with a duplicate MLID does not have these same "flag" fields populated.
## This steps errs on the side of caution so well/demo/qa/qc sites are not assessed.
#mlid_rejects <- unique(stn_new$MonitoringLocationIdentifier[stn_new$IR_FLAG=="REJECT"])
#stn_new$IR_REASON <- ifelse(stn_new$IR_FLAG!="REJECT" & stn_new$MonitoringLocationIdentifier%in%mlid_rejects,"Site shares MLID with rejected site(s)", stn_new$IR_REASON)
#stn_new$IR_FLAG <- ifelse(stn_new$IR_FLAG!="REJECT" & stn_new$MonitoringLocationIdentifier%in%mlid_rejects,"REJECT",stn_new$IR_FLAG)






